{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Reporting and Measure Execution Model","text":"<p>The <code>oa-cohorts</code> library defines the core domain model for constructing, executing, and evaluating clinical quality reports.</p> <p>It compiles configurable logical criteria into SQL, executes them, and materialises qualification events that are propagated upward into indicators and reports.</p> <p>Every logical construct resolves to a set of time-stamped qualification events, represented by the <code>MeasureMember</code> object.</p>"},{"location":"#conceptual-layers","title":"Conceptual Layers","text":""},{"location":"#layer-6-reporting","title":"Layer 6: Reporting","text":"<p>A <code>Report</code> is the top-level orchestration unit combining cohorts and indicators - responsible for coordinated measure execution.  It is defined as a combination of cohorts (what logical unit of patients are in-scope for this specific set of reporting analyses?) and  indicators (whether a defined subset of patients met specific clinical criteria within a defined population and time context.)</p> <p>The object handles aggregation of cohorts and indicators, as well as coordinating measure execution.</p> <p>Because cohorts, indicators and measures are all reusable in multiple report settings, it is simpler for them to operate entirely independently of  the report object, and therefore the <code>Report</code> also handles the special case <code>measure_id = 0</code>, which simply surfaces all members of the full cohort.</p> <p>Reports do not generate SQL directly. They orchestrate execution and consume <code>MeasureMember</code> results.</p> <p></p> <p>The figure illustrates the intended operational model of the reporting engine. Measures resolve into person-level, time-stamped qualification events that are materialised as columns in an underlying report dataset. Indicators and dashboard visualisations are derived directly from these measure definitions, while report-level date filters operate on qualification dates to dynamically include or exclude individuals. This dataset can then be surfaced via external visualisation tools (e.g., Power BI) or exposed through an API to power a RESTful dashboard application.</p>"},{"location":"#layer-5-dash-cohort","title":"Layer 5: Dash Cohort","text":"<p>A <code>DashCohort</code>idefines a clinically meaningful population by grouping one or more cohort definitions, each of which wraps a single measure.</p> <p>A cohort\u2019s members are the union of its underlying definitions.  In downstream reporting systems, those definitions can be surfaced as sub-cohorts for filtering, stratification, or drill-down analysis, but their core purpose is to provide a stable population boundary around which reporting logic operates.</p> <p></p> <p>For example, a Lung Cancer MDT report may draw from separate primary lung and metastatic lung cohorts. A surgical quality report may distinguish between inpatient and day surgery populations while evaluating the same underlying operative measures. In both cases, the clinical criteria remain constant; what changes is the reporting context.</p>"},{"location":"#layer-4-indicators","title":"Layer 4: Indicators","text":"<p>Composes measures into denominators (for whom is this indicator relevant?) and numerators (out of those individuals for whom the indicator is relevant, who met the criteria?).</p> <p>This structure mirrors the way clinical quality is reported in practice: first identify the relevant patients, then evaluate performance within that group.</p> <p></p> <p>At execution time, both numerator and denominator measures must be executable. Each resolves independently into a set of <code>MeasureMember</code> objects, preserving episode alignment and qualification dates. The indicator then derives its membership by intersecting numerator and denominator members, ensuring that only individuals eligible under the denominator contribute to performance calculations.</p> <p>Numerator and denominator each retain their own qualification dates. These dates are not collapsed or overwritten. This allows reporting logic to apply temporal comparators at the report layer, rather than embedding window constraints directly into measure definitions.</p> <p>Indicators often depend on temporal relationships between events.</p> <p>For example:</p> <ul> <li>Treatment within 30 days of death</li> <li>Smoking status documented within 30 days of cohort entry</li> <li>Post-operative mortality within 90 days</li> </ul> <p>In these cases, numerator and denominator measures may each resolve at different dates. The reporting layer applies temporal comparators between these preserved qualification dates.</p> <p></p> <p>This design ensures that:</p> <ul> <li>Clinical logic remains modular</li> <li>Time windowing remains configurable at the report level</li> <li>Indicators can be reused in different reporting contexts</li> </ul>"},{"location":"#layer-3-measure","title":"Layer 3: Measure","text":"<p>Recursive tree of subqueries and/or child measures. </p> <p>Compiles to arbitrary-depth boolean query logic, which when executed produces a set of <code>MeasureMember</code> rows.</p> <p></p> <p>A <code>Measure</code> can be:</p> <ul> <li>Leaf: (wraps a single subquery) </li> <li>Composite (combination of child measures)</li> </ul> <p>Measures do not execute SQL directly \u2014 they compile into SQL via <code>MeasureSQLCompiler</code>, and execution is handled by <code>MeasureExecutor</code>.</p>"},{"location":"#layer-2-subquery","title":"Layer 2: Subquery","text":"<p>A <code>Subquery</code> is the atomic SQL-producing unit.</p> <ul> <li>Combines rule-level selects with <code>UNION ALL</code></li> <li>Driven by one or more <code>QueryRule</code> objects. </li> <li>Acts on a specific <code>RuleTarget</code> (e.g., diagnosis, treatment, observation).</li> <li>For each rule, emits a row that will return results of the canonical <code>MeasureMember</code> shape </li> </ul> <pre><code>{person_id: i, episode_id: e, measure_resolver: x, measure_date: yyyy-mm-dd}\n</code></pre> <p>All subqueries must return these four columns:</p> Column Meaning <code>person_id</code> Individual identifier <code>episode_id</code> Clinical episode (if applicable) <code>measure_resolver</code> Logical grouping key (often episode or event id) <code>measure_date</code> Date at which the criterion was satisfied <p>This shape is enforced so that higher-level logic can safely combine results.</p> <p>Rule Combinations Inside Subqueries</p> <p>If multiple rules exist within a subquery:</p> <ul> <li>Each rule produces its own <code>SELECT</code></li> <li>These are combined with <code>UNION ALL</code></li> </ul> <p>This preserves all qualifying events.</p> <p>Subqueries do not combine with other subqueries \u2014 that is the role of <code>Measure</code>.</p>"},{"location":"#layer-1-queryrule","title":"Layer 1: QueryRule","text":"<p>A <code>QueryRule</code> represents an atomic predicate on a measurable field.</p> <p>Examples:</p> <ul> <li>Diagnosis concept equals X</li> <li>Numeric value greater than Y</li> <li>String value matches pattern Z</li> </ul> <p>A rule does not produce SQL on its own \u2014 it contributes a <code>WHERE</code> clause within a Subquery.</p>"},{"location":"#feeding-results-to-higher-level-reporting-systems-and-visualisers","title":"Feeding results to higher-level reporting systems and visualisers","text":"<p>The system is designed so that:</p> <ul> <li>Every logical construct preserves qualification dates.</li> <li>AND logic synthesises correct qualification moments.</li> <li>OR logic preserves all candidate dates.</li> <li>Resolver alignment prevents false intersections.</li> </ul> <p>At the reporting layer, this enables:</p> <ul> <li>Filtering members by qualification date</li> <li>Computing time windows</li> <li>Evaluating temporal indicators</li> <li>Comparing numerator vs denominator timing</li> </ul>"},{"location":"measurables/","title":"<code>Measurable</code> Abstraction","text":"<p>The <code>Measurable</code> abstraction is the bridge between the engine and the underlying database schema (e.g. OMOP CDM or oncology-specific materialised views).</p> <p>It gives the generalised query resolution pointers to the target columns and tables on which to operate.</p> <p>The <code>Measurable</code> layer is the component that understands:</p> <ul> <li>Which ORM class to query</li> <li>Which columns represent person, episode, and date</li> <li>Which value columns support numeric / concept / string filters</li> </ul> <p>All measurables must emit rows in the canonical form:</p> Column Meaning <code>person_id</code> Individual identifier <code>episode_id</code> Clinical episode <code>measure_resolver</code> Logical grouping key (usually episode) <code>measure_date</code> Date at which criterion was satisfied <p>This shape is required so that:</p> <ul> <li>Subqueries generalise and therefore can combine rule-level filters</li> <li>Measures can apply OR / AND semantics</li> <li>Resolver-aligned joins can occur</li> <li>Higher-level reporting or visualisation layers can filter by qualification date</li> </ul>"},{"location":"measurables/#episode-requirement-cancer-context","title":"Episode Requirement (Cancer Context)","text":"<p>This implementation enforces a hard requirement that all measurable ORM entities must expose an <code>episode_id</code>. This is intentional and oncology-specific.</p> <p>In cancer:</p> <ul> <li>A person may have multiple disease episodes</li> <li>Treatments and staging events must align to specific episodes</li> <li><code>AND</code> logic must join on a resolver representing a clinical context</li> </ul> <p>Without an episode-level resolver:</p> <ul> <li><code>AND</code> logic would collapse to person-level intersection</li> <li>Cross-episode contamination could occur</li> <li>Temporal semantics would be incorrect</li> </ul> <p>Resolver alignment therefore depends on episode-level linkage.</p>"},{"location":"measurables/#measurablespec","title":"<code>MeasurableSpec</code>","text":"<p><code>MeasurableSpec</code> is a declarative mapping from ORM class to the regular shape required to produce measure queries.</p> <p>It defines:</p> <ul> <li>Domain (dx, tx, meas, obs, proc, person)</li> <li>Attribute names for:<ul> <li>person_id</li> <li>episode_id</li> <li>event_date</li> </ul> </li> <li>Optional value attributes:<ul> <li>value_numeric_attr</li> <li>value_concept_attr</li> <li>value_string_attr</li> </ul> </li> <li>Optional temporality overrides</li> <li>Optional valid targets</li> </ul> <p>It references attribute names, not column objects, which allows reuse across different ORM classes.</p>"},{"location":"measurables/#binding-process","title":"Binding Process","text":"<p>When an ORM class subclasses <code>MeasurableBase</code> and defines:</p> <pre><code>__measurable__ = MeasurableSpec(...)\n</code></pre> <p>The <code>__init_subclass__</code> hook automatically binds it to:</p> <pre><code>__bound_measurable__\n</code></pre> <p>This resolves attribute names into actual SQLAlchemy column objects, and the result is a <code>BoundMeasurableSpec</code> that can be actually used by the subquery logic.</p>"},{"location":"measurables/#measurablebase-contract","title":"MeasurableBase Contract","text":"<p><code>MeasurableBase</code> defines the minimal interface required for participation in measure logic.</p> <p>Key methods:</p> <ul> <li><code>person_id_col()</code></li> <li><code>episode_id_col()</code></li> <li><code>event_date_col()</code></li> <li><code>temporal_anchor(temporality)</code></li> <li><code>filter_table()</code></li> <li><code>filter_table_dated(temporality)</code></li> </ul> <p><code>filter_table_dated</code> must return selectables labelled as <code>[person_id, episode_id, measure_resolver, measure_date]</code> to match the contract that a <code>Subquery</code> can operate against.</p>"},{"location":"measurables/#design-constraint","title":"Design Constraint","text":"<p><code>oa_cohorts</code> assumes:</p> <ul> <li>Episode-linked data model</li> <li>Resolver-based AND semantics</li> <li>Canonical four-column output shape</li> </ul> <p>It does not currently support:</p> <ul> <li>Pure person-level resolution</li> <li>Resolver-free AND logic</li> <li>Schemas without episode linkage</li> </ul> <p>Adapting this engine to non-episode-based domains would require redefining the resolver model at the <code>Measurable</code> layer and then using the <code>person_ep_override</code> property at the measure level (and cascaded down) to alias the resolver.</p>"},{"location":"measure_resolution/","title":"Measure Resolution","text":""},{"location":"measure_resolution/#measuremember-atomic-unit-of-result","title":"MeasureMember - atomic unit of result","text":"<p>When a measure is executed, it produces a sequence of:</p> <pre><code>@dataclass(frozen=True)\nclass MeasureMember:\n    person_id: int\n    measure_resolver: int\n    episode_id: Optional[int]\n    measure_date: Optional[date]\n</code></pre> <p>A <code>MeasureMember</code> represents a specific person qualifying for a measure at a specific time, for a specific resolver.</p> <p>It is not only the fact of membership, because it includes resolution to a time-stamped qualification event.  This distinction is critical for reporting, which requires flexible time-windowing periods to produce trends and per-period analysis.</p>"},{"location":"measure_resolution/#measure-combination-semantics","title":"Measure Combination Semantics","text":"<p>Measures use <code>RuleCombination</code> to compose child measures via <code>OR</code> or <code>AND</code>, and the handling of these semantics is significantly different when composing from lower levels.</p> <p></p>"},{"location":"measure_resolution/#or-logic-union-of-qualifying-events","title":"OR Logic: Union of qualifying events","text":"<p><code>OR</code> logic preserves all qualifying rows.</p> <p>Implementation:</p> <ul> <li>Each child measure emits rows</li> <li>Rows are combined using <code>UNION ALL</code></li> <li>Multiple qualification dates are preserved.</li> <li>No resolver alignment is required.</li> <li>Events bubble upward unchanged.</li> </ul> <p>Example:</p> <ul> <li>Measure = ECOG 0 OR ECOG 1</li> </ul> <p>If a person has:</p> <ul> <li>ECOG 0 on Jan 1</li> <li>ECOG 1 on Mar 1</li> </ul> <p>Result: Two <code>MeasureMember</code> rows, with both dates preserved</p>"},{"location":"measure_resolution/#and-logic-resolver-aligned-intersection","title":"AND Logic: Resolver-Aligned Intersection","text":"<p><code>AND</code> logic is not simply \u201cperson appears in both\u201d. It requires that the same resolver must satisfy all child criteria.</p> <p>Implementation:</p> <ul> <li>Each child measure emits canonical rows.</li> <li>Children are joined on measure_resolver.</li> <li>Resolver alignment is required.</li> <li>Qualification date shifts forward to the last satisfied condition.</li> <li>If resolvers differ, the row is excluded.</li> <li>Qualification date becomes: <code>greatest(child_1_date, child_2_date, ...)</code></li> </ul> <p>This represents the earliest moment at which all criteria are true.</p> <p>Example:</p> <ul> <li>Measure = Stage III AND Radiotherapy</li> </ul> <p>If a person has:</p> <ul> <li>Stage III on Jan 1 (episode 10)</li> <li>Radiotherapy on Feb 15 (episode 10)</li> </ul> <p>Result: One row, qualification date = Feb 15</p> <p>If RT occurred under episode 20 instead, there is no result (resolvers do not align)</p>"},{"location":"measure_resolution/#nested-measures","title":"Nested Measures","text":"<p>Measures can be nested arbitrarily:</p> <pre><code>A AND (B OR C)\n</code></pre> <p>Evaluation proceeds bottom-up:</p> <ol> <li>B OR C \u2192 union of events</li> <li>A \u2192 events</li> <li>AND joins A with (B OR C) on resolver</li> <li>Qualification date = greatest of aligned dates</li> </ol> <p>The canonical shape is preserved at every level.</p>"},{"location":"query_rule_definitions/","title":"Atomic Rule Types (<code>QueryRule</code>)","text":"<p><code>QueryRule</code> is the fundamental building block of all cohort and indicator logic.</p> <p>A rule represents a single declarative clinical condition applied to a specific measurable field. They they provide the minimal logical predicates from which subqueries and measures are constructed.</p> <p>Each rule translates into a SQL <code>WHERE</code> clause fragment against a target field defined by a <code>Measurable</code>.</p> <p>At execution time:</p> <ul> <li>A <code>Subquery</code> selects the appropriate field from a measurable.</li> <li>Each <code>QueryRule</code> generates a boolean filter expression.</li> <li>Rule-level selects are combined via <code>UNION ALL</code>.</li> </ul> <p>The sections below describe each supported rule type.</p>"},{"location":"query_rule_definitions/#1-exactrule-exact-concept-match","title":"1. <code>ExactRule</code> \u2014 Exact Concept Match","text":""},{"location":"query_rule_definitions/#semantics","title":"Semantics","text":"<p>Matches records whose concept field is exactly equal to a single OMOP concept.</p>"},{"location":"query_rule_definitions/#sql-shape","title":"SQL Shape","text":"<pre><code>field = concept_id\n</code></pre>"},{"location":"query_rule_definitions/#example-palliative-care-referral","title":"Example \u2014 Palliative Care Referral","text":"<ul> <li>Subquery: Palliative care referral</li> <li>Target: obs_concept</li> <li>Definition: <code>&lt;ExactRule id=139 exact concept=4127745&gt;</code></li> </ul> <p>This matches the concept \u201cReferral to palliative care service\u201d.</p>"},{"location":"query_rule_definitions/#example-lung-surgery","title":"Example \u2014 Lung Surgery","text":"<ul> <li>Subquery: Lung Surgery</li> <li>Target: tx_surgical</li> <li>Multiple ExactRules are combined within the subquery:<ul> <li>Lobectomy</li> <li>Operation on lung</li> <li>Lung excision</li> <li>Total pneumonectomy</li> </ul> </li> </ul> <p>Each rule contributes its own <code>SELECT</code>; the subquery performs a <code>UNION</code>, preserving all qualifying surgical events.</p>"},{"location":"query_rule_definitions/#2-hierarchyrule-inclusive-hierarchical-expansion","title":"2. HierarchyRule \u2014 Inclusive Hierarchical Expansion","text":""},{"location":"query_rule_definitions/#semantics_1","title":"Semantics","text":"<p>Matches a concept and all of its descendants using the OMOP <code>concept_ancestor</code> table.</p>"},{"location":"query_rule_definitions/#sql-shape_1","title":"SQL Shape","text":"<pre><code>field IN (descendant_concept_ids)\n</code></pre>"},{"location":"query_rule_definitions/#example-stage-4-disease","title":"Example \u2014 Stage 4 Disease","text":"<ul> <li>Subquery: Stage 4</li> <li>Target: dx_stage</li> <li>Definition: <code>&lt;HierarchyRule id=45 hierarchy concept=1633987&gt;</code></li> </ul> <p>This expands Stage 4 to include all sub-classifications beneath the parent concept.</p>"},{"location":"query_rule_definitions/#3-hierarchyexclusionrule-hierarchical-exclusion","title":"3. HierarchyExclusionRule \u2014 Hierarchical Exclusion","text":""},{"location":"query_rule_definitions/#semantics_2","title":"Semantics","text":"<p>Excludes a concept and all of its descendants. Used to express definitions such as \u201call X except Y\u201d.</p>"},{"location":"query_rule_definitions/#sql-shape_2","title":"SQL Shape","text":"<pre><code>field NOT IN (descendant_concept_ids)\n</code></pre>"},{"location":"query_rule_definitions/#example-non-squamous-disease","title":"Example \u2014 Non-Squamous Disease","text":"<ul> <li>Subquery: Non-squamous disease</li> <li>Target: dx_primary</li> <li>Definition: <code>&lt;HierarchyExclusionRule id=410 hierarchyexclusion concept=4300118&gt;</code></li> </ul> <p>This excludes squamous cell carcinoma and all its descendants.</p>"},{"location":"query_rule_definitions/#4-presencerule-any-recorded-value","title":"4. PresenceRule \u2014 Any Recorded Value","text":""},{"location":"query_rule_definitions/#semantics_3","title":"Semantics","text":"<p>Matches records where the target field is non-null. Used when the question is simply whether any value exists.</p>"},{"location":"query_rule_definitions/#sql-shape_3","title":"SQL Shape","text":"<pre><code>field IS NOT NULL\n</code></pre>"},{"location":"query_rule_definitions/#example-any-systemic-therapy","title":"Example \u2014 Any Systemic Therapy","text":"<ul> <li>Subquery: Any Systemic Therapy</li> <li>Target: tx_chemotherapy</li> <li>Definition: <code>&lt;PresenceRule id=114 presence&gt;</code></li> </ul> <p>This does not constrain the specific drug \u2014 it only requires that some chemotherapy record exists. The definition for what qualifies as systemic therapy is therefore dependent upon the definition within the specific <code>Measurable</code> mapper class used as the target. In this example it captures the existence of any drug exposure records that have an explicit link to a treatment episode.</p>"},{"location":"query_rule_definitions/#example-death","title":"Example \u2014 Death","text":"<ul> <li>Subquery: Death</li> <li>Target: demog_death</li> <li>Definition:  <p>Matches any non-null death date.</p>"},{"location":"query_rule_definitions/#5-absencerule-explicit-null","title":"5. AbsenceRule \u2014 Explicit Null","text":""},{"location":"query_rule_definitions/#semantics_4","title":"Semantics","text":"<p>Matches records where the field is null. Used to express negative definitions.</p>"},{"location":"query_rule_definitions/#sql-shape_4","title":"SQL Shape","text":"<p><pre><code>field IS NULL\n</code></pre> This supports constructs such as \u201cno documented metastases\u201d or \u201cno recorded procedure\u201d.</p>"},{"location":"query_rule_definitions/#6-scalarrule-numeric-threshold-comparison","title":"6. ScalarRule \u2014 Numeric Threshold Comparison","text":""},{"location":"query_rule_definitions/#semantics_5","title":"Semantics","text":"<p>Applies a numeric comparator to a measurable\u2019s numeric value column.</p> <p>Supports operators: <code>&gt;, &lt;, ==, !=</code></p> <p>The rule optionally constrains comparison to a specific concept.</p> <p>Scalar rules resolve their numeric value column indirectly via the <code>Measurable</code> registry, allowing the same rule abstraction to operate across domains.</p>"},{"location":"query_rule_definitions/#sql-shape_5","title":"SQL Shape","text":"<pre><code>field = concept_id\nAND numeric_value_column &lt; threshold\n</code></pre>"},{"location":"query_rule_definitions/#example-treatment-within-30-days-of-death","title":"Example \u2014 Treatment Within 30 Days of Death","text":"<ul> <li>Subquery: Treatment within 30 days of death</li> <li>Target: tx_to_death_window</li> <li>Definition: <code>&lt;ScalarRule id=409 scalar lt 31 on=tx_to_death_window&gt;</code></li> </ul> <p>This applies a temporal window threshold at the <code>Measurable</code> level, but can be applied to result values or other numeric fields as well.</p>"},{"location":"query_rule_definitions/#7-phenotyperule-curated-concept-group-expansion","title":"7. PhenotypeRule \u2014 Curated Concept Group Expansion","text":""},{"location":"query_rule_definitions/#semantics_6","title":"Semantics","text":"<p>Expands a phenotype definition into a set of concept IDs.</p> <p>Unlike hierarchical expansion, phenotype sets are curated and may not correspond to OMOP hierarchy structure.</p> <p>For very complex and deeply layered definitions, this will typically outperform many layers of combinatorial measures required to execute. This ends up being a tradeoff between a more maintainable measure definition relative to vocabulary updates, versus overly deep nesting that can struggle with large cohorts. </p>"},{"location":"query_rule_definitions/#sql-shape_6","title":"SQL Shape","text":"<pre><code>field IN (phenotype_concept_ids)\n</code></pre>"},{"location":"query_rule_definitions/#example-non-small-cell-lung-cancer-phenotype","title":"Example - Non-Small Cell Lung Cancer Phenotype","text":"<ul> <li>Subquery: Non small cell lung cancer phenotype</li> <li>Target: dx_primary</li> <li>Definition: <code>&lt;PhenotypeRule id=1607 phenotype phenotype=nsclc&gt;</code></li> </ul> <p>Here, the rule does not reference a single concept. Instead, it expands the nsclc phenotype definition into a curated set of concept IDs representing non-small cell lung cancer across coding systems and subtypes.</p> <p>This is particularly useful where histology-driven definitions often do not align cleanly with a single vocabulary branch.</p>"},{"location":"query_rule_definitions/#8-substringrule-concept-code-substring-match","title":"8. SubstringRule \u2014 Concept Code Substring Match","text":""},{"location":"query_rule_definitions/#semantics_7","title":"Semantics","text":"<p>Matches concept codes using substring logic.</p> <p>Used primarily when hierarchical relationships are insufficient or when legacy coding systems rely on structured prefixes.</p>"},{"location":"query_rule_definitions/#sql-shape_7","title":"SQL Shape","text":"<pre><code>field ILIKE '%substring%'\n</code></pre> <p>This is typically a fallback strategy rather than preferred design.</p>"},{"location":"query_rule_definitions/#example-mesothelioma","title":"Example - Mesothelioma","text":"<ul> <li>Subquery: Mesothelioma</li> <li>Target: dx_primary</li> <li>Definition: <code>[&lt;SubstringRule id=151 substring concept=44499065&gt;, &lt;SubstringRule id=152 substring concept=44499069&gt;, &lt;SubstringRule id=153 substring concept=44499067&gt;, &lt;SubstringRule id=154 substring concept=44499070&gt;]</code></li> </ul> <p>Each rule generates its own <code>SELECT</code>. The subquery combines them using UNION ALL, preserving all qualifying diagnosis events.</p>"},{"location":"query_rule_definitions/#summary-rule-type-comparison","title":"Summary Rule Type Comparison","text":"Rule Type Backed By Best Used For Typical Oncology Use Case <code>ExactRule</code> Single OMOP concept ID Precisely coded clinical events Lobectomy; Referral to palliative care <code>HierarchyRule</code> OMOP <code>concept_ancestor</code> expansion Broad disease or procedure groupings Stage 4 disease; Bronchus cancer <code>HierarchyExclusionRule</code> OMOP <code>concept_ancestor</code> expansion \u201cAll except X\u201d definitions Non-squamous lung cancer <code>PresenceRule</code> Field non-null check Existence of any event in domain Any systemic therapy; Death recorded <code>AbsenceRule</code> Field null check Negative definitions No surgery; No documented metastases <code>ScalarRule</code> Numeric value column from <code>Measurable</code> Threshold or temporal comparisons Treatment &lt; 30 days from death; ECOG \u2265 2 <code>PhenotypeRule</code> Curated concept set Composite or research-defined groupings NSCLC phenotype <code>SubstringRule</code> Concept code pattern match Legacy or prefix-based grouping Mesothelioma code block grouping"}]}